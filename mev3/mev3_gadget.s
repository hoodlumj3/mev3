 IFND	MEV3_GADGET_S
MEV3_GADGET_S SET 1

  IFND	MEV3_MAIN_S
	include	"mev3_main.s"
  ENDC

gcWorkScreenDepth	EQU	3
gcPropButtonWidth	EQU	10
gcPropButtonHeight	EQU	10


*									  *
**									 **
***        $VER:mev3_gadget.s 39.01  © (00/April/94) M.J.Edwards        ***
**									 **
*									  *

;********************************************
; GadTool Gadget Creation Deletion Functions
;********************************************

_Create_Gadgets_List:	; d0 - prev gadtool gad, a0 - list of newgadgets (gadtools)
	push	d2-d3/a0
	clr.l	d1		; gadget created counter
.more_gadgets
	tst.l	(a0)		; test for end of GT_gad list
	bmi.s	.no_more_gadgets
	clr.l	d2
	move.w	(a0)+,d2
	move.l	(a0)+,d3
	move.l	_Gl_VisualInfo,gng_VisualInfo(a0) ; do this for every NewGadget Structure before Creating it
	move.l	#_System80,gng_TextAttr(a0)
	push	d3			; tags
	push	a0			; NewGadget struct
	push	d0			; gad from createcontext
	push	d2			; type -> BUTTON_KIND etc.
	bsr	CreateGadget
	lea	4*4(sp),sp
	addq.l	#1,d1			; inc created counter
	add.l	#gng_SIZEOF,a0
	move.l	d0,(a0)+
.more_tags
	bra.s	.more_gadgets
.no_more_gadgets
	pop	d2-d3/a0
	rts

_CreateContext:		; a0 - pointer to gad pointer
	push	a6
	move.l	_GadToolsBase,a6
	jsr	_LVOCreateContext(a6)
	pop	a6
	rts

CreateGadget:	; sp - Type - Gad - NewGadget - Tags
	push	a0-a2/a6
	lea	5*4(sp),a2
	movem.l	(a2)+,d0/a0-a1
	move.l	(a2),a2
	move.l	_GadToolsBase,a6
	jsr	_LVOCreateGadgetA(a6)
	pop	a0-a2/a6
	rts

_FreeGadgets:	; a0 - gadget list generated by create context/gadgets
	push	a6
	move.l	_GadToolsBase,a6
	jsr	_LVOFreeGadgets(a6)
	pop	a6
	rts


    STRUCTURE	SetGadgetType,0
	UWORD	sgt_LeftEdge
	UWORD	sgt_Top
	UWORD	sgt_Width
	UWORD	sgt_Height
	UWORD	sgt_ID
	UWORD	sgt_Number
	LABEL	sgt_SIZEOF

;;- creates gadgets given a list of pre defined structures

; select gadget type
; case : image
;
; case : text
;
; case : tick
;
; case : mx
; 
; case : prop
dbgg1:
_Create_Work_Gadgets:
* d0 - pointer to prev gadget				*
* a0 - SetGadget list					*
*********************************************************

.gadget_next

	tst.w	(a0)		; check for end of list
	bmi	.gadget_end


	push	d0

	move.w	sgt_Number(a0),d0

;
;;	seperate gadget type & text/image number
;

	move.w	d0,d2
	move.w	#GAD_IMAGE!GAD_TICK!GAD_MX!GAD_SETON!GAD_PROP!GAD_TEXT!GAD_STRING,d1
	and.w	d1,d0
	not.w	d1
	and.w	d1,d2
.gadtype_select
	move.w	d0,d1
	andi.w	#GAD_STRING,d1
	cmp.w	#GAD_STRING,d1
	bne.s	.gt_case_not_string

	call	_Setup_String_Gadget































	bra	.gadtype_endselect
.gt_case_not_string
	move.w	d0,d1
	andi.w	#GAD_PROP,d1
	cmp.w	#GAD_PROP,d1
	bne.s	.gt_case_not_prop

	call	_Setup_Prop_Gadget






























	
	bra	.gadtype_endselect
.gt_case_not_prop
	move.w	d0,d1
	andi.w	#GAD_MX,d1
	cmp.w	#GAD_MX,d1
	bne.s	.gt_case_not_mx

	call	_Setup_MX_Tick_Gadget

	push	a0-a1
	move.l	a1,a0
	add.l	#gg_SIZEOF+it_SIZEOF+32,a1
	call	_Setup_And_Blit_MX	; put image into gadget mem
;	move.l	a1,gg_GadgetRender(a0)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,gg_SelectRender(a0)
	pop	a0-a1

	move.w	#GACT_RELVERIFY!GACT_IMMEDIATE!GACT_TOGGLESELECT,gg_Activation(a1)
	move.w	gg_UserData(a1),d0














	andi.w	#GAD_SETON,d0
	beq.s	.mx_not_on
	or.w	#GFLG_SELECTED,gg_Flags(a1)
.mx_not_on

	bra	.gadtype_endselect
.gt_case_not_mx
	move.w	d0,d1
	andi.w	#GAD_TICK,d1
	cmp.w	#GAD_TICK,d1
	bne.s	.gt_case_not_tick

	call	_Setup_MX_Tick_Gadget

	push	a0-a1
	move.l	a1,a0
	add.l	#gg_SIZEOF+it_SIZEOF+32,a1
	call	_Setup_And_Blit_Tick	; put image into gadget mem
;	move.l	a1,gg_GadgetRender(a0)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,gg_SelectRender(a0)
	pop	a0-a1

	move.w	#GACT_RELVERIFY!GACT_IMMEDIATE!GACT_TOGGLESELECT,gg_Activation(a1)
	move.w	gg_UserData(a1),d0














	andi.w	#GAD_SETON,d0
	beq.s	.tick_not_on
	or.w	#GFLG_SELECTED,gg_Flags(a1)
.tick_not_on

	bra	.gadtype_endselect
.gt_case_not_tick
	move.w	d0,d1
	andi.w	#GAD_TEXT,d1
	cmp.w	#GAD_TEXT,d1
	bne.s	.gt_case_not_text

	call	_Setup_Button_Gadget

	push	a0-a1
	move.l	a1,a0
	add.l	#gg_SIZEOF,a1
	push	a0-a1
	call	_Setup_And_Blit_Border	; put border into gadget mem
	pull	a0-a1
	call	_Setup_And_Blit_Text	; put image into gadget mem
	pop	a0-a1
	move.l	a1,gg_GadgetRender(a0)
	add.l	#ig_SIZEOF,a1
	move.l	a1,gg_SelectRender(a0)
	pop	a0-a1


















	bra	.gadtype_endselect
.gt_case_not_text
	move.w	d0,d1
	andi.w	#GAD_IMAGE,d1
	cmp.w	#GAD_IMAGE,d1
	bne.s	.gt_case_not_image

	call	_Setup_Button_Gadget

	push	a0-a1
	move.l	a1,a0
	add.l	#gg_SIZEOF,a1
	push	a0-a1
	call	_Setup_And_Blit_Border	; put border into gadget mem
	pull	a0-a1
	call	_Setup_And_Blit_Image	; put image into gadget mem
	pop	a0-a1
	move.l	a1,gg_GadgetRender(a0)
	add.l	#ig_SIZEOF,a1
	move.l	a1,gg_SelectRender(a0)
	pop	a0-a1
	
	bra	.gadtype_endselect

.gt_case_not_image
	add.l	#sgt_SIZEOF,a0
;	bra.s	.gadtype_endselect
.gadtype_endselect

	pop	d0

	tst.l	d0
	beq.s	.no_previous_gadget
	move.l	d0,a2			; move prev to a0
	move.l	a1,gg_NextGadget(a2)	; link new gad(a1) to prev gadget (a0)
.no_previous_gadget
	move.l	a1,d0

	bra	.gadget_next
.gadget_end	
	rts

_Calc_Button_Mem_Size:
	moveq.l	#0,d0
	move.w	sgt_Width(a0),d0
	add.w	#$F,d0
	asr.w	#4,d0
	add.w	d0,d0
	mulu	sgt_Height(a0),d0
	mulu	#gcWorkScreenDepth,d0
	rts

_Setup_Button_Gadget:	; a0 - set_gadget_type def
	call	_Calc_Button_Mem_Size
	push	d0			; size of 1 image
	add.l	d0,d0			; *2 for 2 images (selected,rendered)
	add.l	#gg_SIZEOF+(ig_SIZEOF*2),d0
	push	a0
	call	_Malloc_CHIP		; exit if can't get any mem
	move.l	d0,a1
	pop	a0
	movem.w	(a0)+,d1-d6
	move.w	d1,gg_LeftEdge(a1)
	move.w	d2,gg_TopEdge(a1)
	move.w	d3,gg_Width(a1)
	move.w	d4,gg_Height(a1)
	move.w	d5,gg_GadgetID(a1)
	move.w	d6,gg_UserData(a1)	; write data into dummy gadget

	move.w	#GTYP_BOOLGADGET,gg_GadgetType(a1)
	move.w	#GFLG_GADGHIMAGE!GFLG_GADGIMAGE,gg_Flags(a1)
	move.w	#GACT_RELVERIFY!GACT_IMMEDIATE,gg_Activation(a1)

	pop	d0			; get back size of 1 image

	push	a0-a2
	move.l	a1,a2
	add.l	#gg_SIZEOF+(ig_SIZEOF*2),a2
	move.l	a1,a0
	add.l	#gg_SIZEOF,a1
	
	moveq.l	#0,d1
	move.w	d1,(a1)+		; ig_LeftEdge
	move.w	d1,(a1)+		; ig_TopEdge
	move.w	gg_Width(a0),(a1)+	; ig_Width
	move.w	gg_Height(a0),(a1)+	; ig_Height
	move.w	#gcWorkScreenDepth,(a1)+; ig_Depth
	move.l	a2,(a1)+		; ig_ImageData
	move.w	#$0707,(a1)+		; ig_PanePick & ig_PlaneOnOff
	move.l	d1,(a1)+		; ig_NextImage

	add.l	d0,a2

	moveq.l	#0,d1
	move.w	d1,(a1)+		; ig_LeftEdge
	move.w	d1,(a1)+		; ig_TopEdge
	move.w	gg_Width(a0),(a1)+	; ig_Width
	move.w	gg_Height(a0),(a1)+	; ig_Height
	move.w	#gcWorkScreenDepth,(a1)+; ig_Depth
	move.l	a2,(a1)+		; ig_ImageData
	move.w	#$0707,(a1)+		; ig_PanePick & ig_PlaneOnOff
	move.l	d1,(a1)+		; ig_NextImage

	pop	a0-a2

	rts

_Setup_MX_Tick_Gadget:	; a0 - set_gadget_type def	
; gg_
; ig_1
; ig_2
; it_
; it_text (32)
; ig_1_image
; ig_2_image

	call	_Calc_Button_Mem_Size
	push	d0			; size of 1 image
	add.l	d0,d0			; *2 for 2 images (selected,rendered)
	add.l	#gg_SIZEOF+(ig_SIZEOF*2),d0
	add.l	#it_SIZEOF+32,d0
	push	a0
	call	_Malloc_CHIP		; exit if can't get any mem
	move.l	d0,a1
	pop	a0
	movem.w	(a0)+,d1-d6
	move.w	d1,gg_LeftEdge(a1)
	move.w	d2,gg_TopEdge(a1)
	move.w	d3,gg_Width(a1)
	move.w	d4,gg_Height(a1)
	move.w	d5,gg_GadgetID(a1)
	move.w	d6,gg_UserData(a1)	; write data into gadget

	move.w	#GTYP_BOOLGADGET,gg_GadgetType(a1)
	move.w	#GFLG_GADGHIMAGE!GFLG_GADGIMAGE,gg_Flags(a1)
	move.w	#GACT_RELVERIFY!GACT_IMMEDIATE!GACT_TOGGLESELECT,gg_Activation(a1)

	pop	d0			; get back size of 1 image

	push	a0-a2
	move.l	a1,a0
	add.l	#gg_SIZEOF,a1
	move.l	a1,a2
	add.l	#(ig_SIZEOF*2),a2
	add.l	#it_SIZEOF+32,a2

	move.l	a1,gg_GadgetRender(a0)

; setup image render	
	moveq.l	#0,d1
	move.w	d1,(a1)+		; ig_LeftEdge
	move.w	d1,(a1)+		; ig_TopEdge
	move.w	gg_Width(a0),(a1)+	; ig_Width
	move.w	gg_Height(a0),(a1)+	; ig_Height
	move.w	#gcWorkScreenDepth,(a1)+; ig_Depth
	move.l	a2,(a1)+		; ig_ImageData
	move.w	#$0707,(a1)+		; ig_PanePick & ig_PlaneOnOff
	move.l	d1,(a1)+		; ig_NextImage

	add.l	d0,a2

; setup image select	

	move.l	a1,gg_SelectRender(a0)

	moveq.l	#0,d1
	move.w	d1,(a1)+		; ig_LeftEdge
	move.w	d1,(a1)+		; ig_TopEdge
	move.w	gg_Width(a0),(a1)+	; ig_Width
	move.w	gg_Height(a0),(a1)+	; ig_Height
	move.w	#gcWorkScreenDepth,(a1)+; ig_Depth
	move.l	a2,(a1)+		; ig_ImageData
	move.w	#$0707,(a1)+		; ig_PanePick & ig_PlaneOnOff
	move.l	d1,(a1)+		; ig_NextImage

	move.l	a1,gg_GadgetText(a0)	; write in gadget text

	lea	it_SIZEOF(a1),a2	; where text goes

; setup intuitext
	move.b	#1,(a1)+		; it_FrontPen
	move.b	#0,(a1)+		; it_BackPen
	move.b	#RP_JAM2,(a1)+		; it_DrawMode
	move.b	#0,(a1)+		; it_KludgeFill00
	move.w	gg_Width(a0),d1		
	add.w	#4,d1			
	move.w	d1,(a1)+		; it_LeftEdge
	move.w	#1,(a1)+		; it_TopEdge
	moveq.l	#0,d1
	move.l	d1,(a1)+		; it_ITextFont

	move.l	a2,(a1)+		; it_IText
	move.l	d1,(a1)+		; it_NextText

	move.w	gg_UserData(a0),d0
	andi.w	#$0FFF,d0
	call	_Retrieve_Text
	
	move.l	d0,a0
	move.l	a2,a1
	moveq.l	#31,d0			; make sure we copy only 31 bytes of text
	call	_StrnCpy
	move.b	#0,31(a1)		; and null to 31st for eot
	pop	a0-a2

	rts

_Setup_Prop_Gadget:	; a0 - set_gadget_type def
	moveq.l	#0,d0
	add.l	#gg_SIZEOF+pi_SIZEOF+ig_SIZEOF,d0
	push	a0
	call	_Malloc_CHIP		; exit if can't get any mem
	move.l	d0,a1
	pop	a0
	movem.w	(a0)+,d1-d6
	addq.w	#2,d1
	move.w	d1,gg_LeftEdge(a1)
	addq.w	#1,d2
	move.w	d2,gg_TopEdge(a1)
	subq.w	#4,d3
	move.w	d3,gg_Width(a1)
	subq.w	#2,d4
	move.w	d4,gg_Height(a1)
	move.w	d5,gg_GadgetID(a1)
	move.w	d6,gg_UserData(a1)	; write data into dummy gadget

	move.w	#GTYP_PROPGADGET,gg_GadgetType(a1)
	move.w	#GFLG_GADGHNONE,gg_Flags(a1)
	move.w	#GACT_RELVERIFY!GACT_FOLLOWMOUSE!GACT_IMMEDIATE,gg_Activation(a1)

	push	a0-a2
	move.l	a1,a0
	add.l	#gg_SIZEOF,a1
	move.l	a1,a2
	add.l	#pi_SIZEOF,a2
	
	move.l	a1,gg_SpecialInfo(a0)
	move.l	a2,gg_GadgetRender(a0)

	move.w	#AUTOKNOB!FREEHORIZ!PROPBORDERLESS!PROPNEWLOOK,pi_Flags(a1)
	move.w	#65535/255,pi_HorizBody(a1)
	move.w	#0,pi_VertBody(a1)
	
	pop	a0-a2

	rts

_Get_WorkGadgetStringInteger:	; d0 - gadget_ID
	push	a0
	move.l	_Wk_Window,a0
	move.l	wd_FirstGadget(a0),a0
	call	_Find_GadgetID
	move.l	a0,d0
	move.l	d0,a0
	beq.s	.gadget_set_buffer
	move.w	gg_GadgetType(a0),d0
	andi.w	#GTYP_STRGADGET,d0
	bne.s	.str_gad_found

.gadget_set_buffer
;	lea	_Buffer256,a0
	moveq.l	#-1,d0
	bra.s	.gadget_not_found
.str_gad_found
	move.l	gg_SpecialInfo(a0),a0
	move.l	si_LongInt(a0),d0
	
.gadget_not_found
	pop	a0
	rts

_Get_WorkGadgetStringBuffer:	; d0 - gadget_ID
	move.l	_Wk_Window,a0
	move.l	wd_FirstGadget(a0),a0
	call	_Find_GadgetID
	move.l	a0,d0
	move.l	d0,a0
	beq.s	.gadget_set_buffer
	move.w	gg_GadgetType(a0),d0
	andi.w	#GTYP_STRGADGET,d0
	bne.s	.str_gad_found
.gadget_set_buffer
	lea	_Buffer256,a0
	bra.s	.gadget_not_found
.str_gad_found
	move.l	gg_SpecialInfo(a0),a0
	move.l	si_Buffer(a0),a0
	
.gadget_not_found
	rts



_Setup_String_Gadget:	; a0 - set_gadget_type def
	call	_Calc_Button_Mem_Size

;	moveq.l	#0,d0
;	move.w	sgt_Width(a0),d0
;	add.w	#$F,d0
;	asr.w	#4,d0
;	add.w	d0,d0
;	mulu	sgt_Height(a0),d0
;	mulu	#gcWorkScreenDepth,d0

	add.l	#gg_SIZEOF+ig_SIZEOF+si_SIZEOF+256,d0
	push	a0
	call	_Malloc_CHIP		; exit if can't get any mem
	move.l	d0,a1
	pop	a0
	movem.w	(a0)+,d1-d6
	move.w	d1,gg_LeftEdge(a1)
	move.w	d2,gg_TopEdge(a1)
	move.w	d3,gg_Width(a1)
	move.w	d4,gg_Height(a1)
	move.w	d5,gg_GadgetID(a1)
	move.w	d6,gg_UserData(a1)	; write data into gadget

	move.w	#GTYP_STRGADGET,gg_GadgetType(a1)
	move.w	#GFLG_GADGHCOMP!GFLG_GADGIMAGE,gg_Flags(a1)
	move.w	#GACT_STRINGLEFT!GACT_RELVERIFY!GACT_IMMEDIATE,gg_Activation(a1)

	push	a0-a2
	move.l	a1,a0				; gg_ to a0
	add.l	#gg_SIZEOF,a1
	move.l	a1,a2				; image struct
	add.l	#ig_SIZEOF+si_SIZEOF+256,a2	; image pointer

	move.l	a1,gg_GadgetRender(a0)		; write in border image

; a0 - gg_
; a1 - ig_
; a2 - image pointer


	moveq.l	#0,d1
	move.w	#-2,(a1)+		; ig_LeftEdge
	move.w	#-2,(a1)+		; ig_TopEdge
	move.w	gg_Width(a0),(a1)+		; ig_Width
	move.w	gg_Height(a0),(a1)+		; ig_Height
	move.w	#gcWorkScreenDepth,(a1)+; ig_Depth
	move.l	a2,(a1)+		; ig_ImageData
	move.w	#$0707,(a1)+		; ig_PlanePick & ig_PlaneOnOff
	move.l	d1,(a1)+		; ig_NextImage

	move.l	a1,a2
	add.l	#si_SIZEOF,a1		; ptr to buffer
; a0 - gg_
; a1 - strbuffer
; a2 - si_
	move.l	a1,si_Buffer(a2)		; setup buffer
	move.w	#255,si_MaxChars(a2)		; max character allowable
	move.l	a2,gg_SpecialInfo(a0)		; si_???		

	
	push	a0				; setup image rastport for border of string
	moveq.l	#gcWorkScreenDepth,d0
	move.w	gg_Width(a0),d1
	move.w	gg_Height(a0),d2
	moveq.l	#1,d3
	add.l	#gg_SIZEOF+ig_SIZEOF+si_SIZEOF+256,a0

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort

	call	_Setup_To_BitMapRastPort

	pop	a0

	moveq.l	#0,d0
	moveq.l	#0,d1
	move.w	gg_Width(a0),d2
	move.w	gg_Height(a0),d3
	subq.w	#1,d2
	subq.w	#1,d3

	addq.w	#2,gg_LeftEdge(a0)
	addq.w	#2,gg_TopEdge(a0)
	subq.w	#4,gg_Width(a0)
	subq.w	#2,gg_Height(a0)

	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort

	call	_Draw_Lowered_Hires_Box		; draw the border in bitmap

	

	pop	a0-a2	
	
	rts

_Work_Image_Sizes:	DS.B	MAX_WORK_IMAGES*2


    STRUCTURE	SetBlitImage,0
	APTR	sbi_GadgetStruct	;x
	APTR	sbi_Image1Struct	;x
	APTR	sbi_Image2Struct	;x
	APTR	sbi_Image1Mem		;x
	APTR	sbi_Image2Mem		;x
	ULONG	sbi_ImageMemSize	;x
	UWORD	sbi_ImgWidth		;x
	UWORD	sbi_ImgHeight		;x
	APTR	sbi_ImgImage		;x
	LABEL	sbi_SIZEOF

_Setup_To_BitMapRastPort:	; d0 - depth, d1 - width, d2 - height, d3 - #, a0 - mem ptr
	lea	_BitMap_To,a1
	call	_CreateBitMap		; setup the to bitmap for render
	lea	_BitMap_To,a0
	lea	_RastPort_To,a1
	call	_CreateRastPort
	rts

_Calc_ImgWHFromGadget:	; a0 - gg_struct, a1 - mem for everything, lo(a4) - local : should only be called with SetBlitImage struct on stack
	move.l	a0,sbi_GadgetStruct(lo)
	move.l	a1,sbi_Image1Struct(lo)
	add.l	#ig_SIZEOF,a1
	move.l	a1,sbi_Image2Struct(lo)
	add.l	#ig_SIZEOF,a1
	move.l	a1,sbi_Image1Mem(lo)

	moveq.l	#0,d0
	move.w	gg_Width(a0),d0
	move.w	d0,sbi_ImgWidth(lo)
	add.w	#$F,d0
	asr.w	#4,d0
	add.w	d0,d0
	move.w	gg_Height(a0),d1
	move.w	d1,sbi_ImgHeight(lo)
	mulu	d1,d0
	mulu	#gcWorkScreenDepth,d0

	move.l	d0,sbi_ImageMemSize(lo)
	add.l	sbi_Image1Mem(lo),d0
	move.l	d0,sbi_Image2Mem(lo)	; setup image pointers 1 & 2
	rts

_Get_ImgSWHD_4_To_Bitmap:
	moveq.l	#gcWorkScreenDepth,d0
	move.w	sbi_ImgWidth(lo),d1
	move.w	sbi_ImgHeight(lo),d2
	moveq.l	#1,d3
	rts

_Get_Img1WHD_4_To_Bitmap:
	call	_Get_ImgSWHD_4_To_Bitmap
	move.l	sbi_Image1Mem(lo),a0
	rts

_Get_Img2WHD_4_To_Bitmap:
	call	_Get_ImgSWHD_4_To_Bitmap
	move.l	sbi_Image2Mem(lo),a0
	rts

_Retrieve_Text:	; d0 - text # in "work_text"
	push	d1/a0
	lea	_Work_Text,a0
	moveq.l	#0,d1
.check_next_text
	tst.b	(a0)			; check if end of list
	bmi.s	.end_of_text_list
	cmp.w	d0,d1
	beq.s	.text_found
	push	d0
	call	_StrLen
	addq.l	#1,d0			; for null (EOString)
	add.l	d0,a0
	pop	d0
	addq.l	#1,d1
	bra.s	.check_next_text
.text_found
	move.l	a0,d0
.end_of_text_list

	pop	d1/a0	; d0 - text if found
	rts

dbgg3:
_Setup_And_Blit_Border:	; a0 - gadget struct, a1 - image memory
	nop
	push	lo
	sub.l	#sbi_SIZEOF,sp
	move.l	sp,lo
	push	a0-a1

	call	_Calc_ImgWHFromGadget

;	move.l	a0,sbi_GadgetStruct(lo)
;	move.l	a1,sbi_Image1Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image2Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image1Mem(lo)

;	moveq.l	#0,d0
;	move.w	gg_Width(a0),d0
;	move.w	d0,sbi_ImgWidth(lo)
;	add.w	#$F,d0
;	asr.w	#4,d0
;	add.w	d0,d0
;	move.w	gg_Height(a0),d1
;	move.w	d1,sbi_ImgHeight(lo)
;	mulu	d1,d0
;	mulu	#gcWorkScreenDepth,d0
	
;	move.l	d0,sbi_ImageMemSize(lo)
;	add.l	sbi_Image1Mem(lo),d0
;	move.l	d0,sbi_Image2Mem(lo)	; setup image pointers 1 & 2
	
;	moveq.l	#gcWorkScreenDepth,d0
;	move.w	sbi_ImgWidth(lo),d1
;	move.w	sbi_ImgHeight(lo),d2
;	moveq.l	#1,d3
;	move.l	sbi_Image1Mem(lo),a0

	call	_Get_Img1WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort


	moveq.l	#0,d0
	moveq.l	#0,d1
	move.w	sbi_ImgWidth(lo),d2
	move.w	sbi_ImgHeight(lo),d3
	subq.w	#1,d2
	subq.w	#1,d3
	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort

	push	d0-d3
	call	_Draw_Raised_Hires_Box


;	moveq.l	#gcWorkScreenDepth,d0
;	move.w	sbi_ImgWidth(lo),d1
;	move.w	sbi_ImgHeight(lo),d2
;	moveq.l	#1,d3
;	move.l	sbi_Image2Mem(lo),a0

	call	_Get_Img2WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort

	pop	d0-d3

	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort

	call	_Draw_Lowered_Hires_Box


	pop	a0-a1
	add.l	#sbi_SIZEOF,sp
	pop	lo
	
	rts





dbgg2:
_Setup_And_Blit_Image:	; a0 - gadget struct, a1 - image memory
	push	lo
	sub.l	#sbi_SIZEOF,sp
	move.l	sp,lo
	push	a0-a1

	call	_Calc_ImgWHFromGadget

;	move.l	a0,sbi_GadgetStruct(lo)
;	move.l	a1,sbi_Image1Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image2Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image1Mem(lo)

;	moveq.l	#0,d0
;	move.w	gg_Width(a0),d0
;	add.w	#$F,d0
;	asr.w	#4,d0
;	add.w	d0,d0
;	mulu	gg_Height(a0),d0
;	mulu	#gcWorkScreenDepth,d0
	
;	move.l	d0,sbi_ImageMemSize(lo)
;	add.l	sbi_Image1Mem(lo),d0
;	move.l	d0,sbi_Image2Mem(lo)	; setup image pointers 1 & 2
	
	
	moveq.l	#0,d0
	move.w	gg_UserData(a0),d0
	lea	_Work_Image_Sizes,a1
	add.w	d0,d0
	add.w	d0,a1
	clr.l	d0
	move.b	0(a1),d0
	move.w	d0,sbi_ImgWidth(lo)
	move.b	1(a1),d0
	move.w	d0,sbi_ImgHeight(lo)	; get width & height of stored image

	lea	_Work_Image,a1		; get defs from images stored 
	
	moveq.l	#0,d0
	move.l	d0,d1
	move.l	d1,d2
	move.b	ft_Depth(a1),d0
	move.b	ft_Width(a1),d1
	move.b	ft_Height(a1),d2
	push	d0-d2
	add.w	#$F,d1
	asr.w	#4,d1
	add.w	d1,d1
	mulu	d1,d0
	mulu	d2,d0
	mulu	gg_UserData(a0),d0
	push	d0
	moveq.l	#0,d0
	move.b	ft_Depth(a1),d0
	call	_Power_Of_2
	add.l	d0,d0
	add.l	d0,a1			; skip colours
	pop	d0
	addq.l	#6,a1			; skip definitions
	add.l	d0,a1			; skip to image
	pop	d0-d2
	moveq.l	#1,d3
	move.l	a1,sbi_ImgImage(lo)
	move.l	a1,a0
	lea	_BitMap_From,a1
	call	_CreateBitMap

	move.l	sbi_GadgetStruct(lo),a0

	moveq.l	#gcWorkScreenDepth,d0
	move.w	gg_Width(a0),d1
	move.w	gg_Height(a0),d2
	moveq.l	#1,d3
	move.l	sbi_Image1Mem(lo),a0

;	call	_Get_Img1WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render

	moveq.l	#0,d0
	move.l	d0,d1
	move.l	d0,d2
	move.l	d0,d3
	move.l	d0,d4
	move.l	d0,d5
	moveq.l	#2,d2
	moveq.l	#1,d3
	move.w	sbi_ImgWidth(lo),d4
	move.w	sbi_ImgHeight(lo),d5
	move.w	#$CC,d6
	move.w	#$FF,d7	
	lea	_BitMap_From,a0
	lea	_BitMap_To,a1
	call	_BltBitMap		; blit the render image

	push	d0-d7/a0-a1

	move.l	sbi_GadgetStruct(lo),a0

	moveq.l	#gcWorkScreenDepth,d0
	move.w	gg_Width(a0),d1
	move.w	gg_Height(a0),d2
	moveq.l	#1,d3
	move.l	sbi_Image2Mem(lo),a0

;	call	_Get_Img2WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; create the to bitmap for select

	pop	d0-d7/a0-a1
;	addq.w	#1,d2
;	addq.w	#1,d3
;	subq.w	#1,d4
;	subq.w	#1,d5
	call	_BltBitMap		; blit the select image

	pop	a0-a1
	add.l	#sbi_SIZEOF,sp
	pop	lo
	rts



_Setup_And_Blit_Text:	; a0 - gadget struct, a0 - image memory
	push	lo
	sub.l	#sbi_SIZEOF,sp
	move.l	sp,lo
	push	a0-a1

	call	_Calc_ImgWHFromGadget

;	move.l	a0,sbi_GadgetStruct(lo)
;	move.l	a1,sbi_Image1Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image2Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image1Mem(lo)

;	moveq.l	#0,d0
;	move.w	gg_Width(a0),d0
;	move.w	d0,sbi_ImgWidth(lo)
;	add.w	#$F,d0
;	asr.w	#4,d0
;	add.w	d0,d0
;	move.w	gg_Height(a0),d1
;	move.w	d1,sbi_ImgHeight(lo)
;	mulu	d1,d0
;	mulu	#gcWorkScreenDepth,d0
	
;	move.l	d0,sbi_ImageMemSize(lo)
;	add.l	sbi_Image1Mem(lo),d0
;	move.l	d0,sbi_Image2Mem(lo)	; setup image pointers 1 & 2
	
;	moveq.l	#gcWorkScreenDepth,d0
;	move.w	sbi_ImgWidth(lo),d1
;	move.w	sbi_ImgHeight(lo),d2
;	moveq.l	#1,d3
;	move.l	sbi_Image1Mem(lo),a0

	call	_Get_Img1WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort



	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort

	pull	a0-a1
	moveq.l	#0,d0
	move.w	gg_UserData(a0),d0

	andi.w	#$0FFF,d0

	move.w	gg_Width(a0),d1		; get width
	move.w	gg_Height(a0),d2	; get height
	sub.w	#7,d2
	asr.w	#1,d2
	move.w	d2,d4			; top(y)
	call	_Retrieve_Text		; get text
	move.l	d0,a0			; text pointer to a0
	call	_StrLen			; get length of string
	move.l	d0,d5			; length

	asl.w	#3,d0			; num pixels width *8
	sub.w	d0,d1
	asr.w	#1,d1
	move.l	d1,d3			; left(x)
	
	push	d3-d5
	pop	d0-d2
	push	d0-d2/a0
	call	_DisplayText

;	moveq.l	#gcWorkScreenDepth,d0
;	move.w	sbi_ImgWidth(lo),d1
;	move.w	sbi_ImgHeight(lo),d2
;	moveq.l	#1,d3
;	move.l	sbi_Image2Mem(lo),a0

	call	_Get_Img2WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort

	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort
	pop	d0-d2/a0

	call	_DisplayText

	pop	a0-a1
	add.l	#sbi_SIZEOF,sp
	pop	lo

	rts


_Setup_And_Blit_Tick:	; a0 - gadget struct, a1 - image memory
	push	lo
	sub.l	#sbi_SIZEOF,sp
	move.l	sp,lo
	push	a0-a1

	call	_Calc_ImgWHFromGadget

;	move.l	a0,sbi_GadgetStruct(lo)
;	move.l	a1,sbi_Image1Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image2Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image1Mem(lo)

;	moveq.l	#0,d0
;	move.w	gg_Width(a0),d0
;	move.w	d0,sbi_ImgWidth(lo)
;	add.w	#$F,d0
;	asr.w	#4,d0
;	add.w	d0,d0
;	move.w	gg_Height(a0),d1
;	move.w	d1,sbi_ImgHeight(lo)
;	mulu	d1,d0
;	mulu	#gcWorkScreenDepth,d0

;	move.l	d0,sbi_ImageMemSize(lo)
;	add.l	sbi_Image1Mem(lo),d0
;	move.l	d0,sbi_Image2Mem(lo)	; setup image pointers 1 & 2
		
;	moveq.l	#gcWorkScreenDepth,d0
;	move.w	sbi_ImgWidth(lo),d1
;	move.w	sbi_ImgHeight(lo),d2
;	moveq.l	#1,d3
;	move.l	sbi_Image1Mem(lo),a0

	call	_Get_Img1WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort



	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort

	lea	_Tick_Border_Tick_On,a0
	moveq.l	#0,d0
	moveq.l	#0,d1
	call	_DrawBorder

;	moveq.l	#gcWorkScreenDepth,d0
;	move.w	sbi_ImgWidth(lo),d1
;	move.w	sbi_ImgHeight(lo),d2
;	moveq.l	#1,d3
;	move.l	sbi_Image2Mem(lo),a0

	call	_Get_Img2WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort

	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort

	lea	_Tick_Border_Tick_Off,a0
	moveq.l	#0,d0
	moveq.l	#0,d1
	call	_DrawBorder

	pop	a0-a1
	add.l	#sbi_SIZEOF,sp
	pop	lo

	rts

_Setup_And_Blit_MX:	; a0 - gadget struct, a0 - image memory
	push	lo
	sub.l	#sbi_SIZEOF,sp
	move.l	sp,lo
	push	a0-a1

	call	_Calc_ImgWHFromGadget

;	move.l	a0,sbi_GadgetStruct(lo)
;	move.l	a1,sbi_Image1Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image2Struct(lo)
;	add.l	#ig_SIZEOF,a1
;	move.l	a1,sbi_Image1Mem(lo)

;	moveq.l	#0,d0
;	move.w	gg_Width(a0),d0
;	move.w	d0,sbi_ImgWidth(lo)
;	add.w	#$F,d0
;	asr.w	#4,d0
;	add.w	d0,d0
;	move.w	gg_Height(a0),d1
;	move.w	d1,sbi_ImgHeight(lo)
;	mulu	d1,d0
;	mulu	#gcWorkScreenDepth,d0
	
;	move.l	d0,sbi_ImageMemSize(lo)
;	add.l	sbi_Image1Mem(lo),d0
;	move.l	d0,sbi_Image2Mem(lo)	; setup image pointers 1 & 2
		
;	moveq.l	#gcWorkScreenDepth,d0
;	move.w	sbi_ImgWidth(lo),d1
;	move.w	sbi_ImgHeight(lo),d2
;	moveq.l	#1,d3
;	move.l	sbi_Image1Mem(lo),a0

	call	_Get_Img1WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort


	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort


	lea	_Mx_Border_Mx_On,a0
	moveq.l	#0,d0
	moveq.l	#0,d1
	call	_DrawBorder

;	moveq.l	#gcWorkScreenDepth,d0
;	move.w	sbi_ImgWidth(lo),d1
;	move.w	sbi_ImgHeight(lo),d2
;	moveq.l	#1,d3
;	move.l	sbi_Image2Mem(lo),a0

	call	_Get_Img2WHD_4_To_Bitmap
	call	_Setup_To_BitMapRastPort

;	lea	_BitMap_To,a1
;	call	_CreateBitMap		; setup the to bitmap for render
;	lea	_BitMap_To,a0
;	lea	_RastPort_To,a1
;	call	_CreateRastPort

	lea	_RastPort_To,a0
	move.l	a0,_Global_RastPort

	lea	_Mx_Border_Mx_Off,a0
	moveq.l	#0,d0
	moveq.l	#0,d1
	call	_DrawBorder

	pop	a0-a1
	add.l	#sbi_SIZEOF,sp
	pop	lo

	rts


;;- creates gadgets given a list of pre defined structures

; select gadget type
; case : image
;
; case : text
;
; case : tick
;
; case : mx
; 
; case : prop




_Tick_Border_Tick_On:	DC.L	$00000000,$00000007,_Tick_BC_Tick,_Tick_Border_Shine
_Tick_Border_Tick_Off:	DC.L	$00000000,$01000007,_Tick_BC_Tick,_Tick_Border_Shine
_Tick_Border_Shine:	DC.L	$00000000,$02000005,_Tick_BC_Shine,_Tick_Border_Shadow
_Tick_Border_Shadow:	DC.L	$00000000,$03000005,_Tick_BC_Shadow,0

_Tick_BC_Tick:		DC.W	09,06, 13,02, 12,02, 08,06, 07,06, 07,05, 05,05
_Tick_BC_Shine:		DC.W	16,00, 00,00, 00,08, 01,07, 01,01
_Tick_BC_Shadow:	DC.W	01,08, 17,08, 17,00, 16,01, 16,07

_Mx_Border_Mx_Off:	DC.L	$00000000,$0500001C,_Mx_BC_Center,_Mx_Border_OutTL_Off
_Mx_Border_OutTL_Off:	DC.L	$00000000,$00000004,_Mx_BC_BlankTL,_Mx_Border_OutBL_Off	; tl blank bit
_Mx_Border_OutBL_Off:	DC.L	$00000000,$00000004,_Mx_BC_BlankBL,_Mx_Border_OutTR_Off	; bl
_Mx_Border_OutTR_Off:	DC.L	$00000000,$00000004,_Mx_BC_BlankTR,_Mx_Border_OutBR_Off	; tr
_Mx_Border_OutBR_Off:	DC.L	$00000000,$00000004,_Mx_BC_BlankBR,_Mx_Border_Shine_Off	; br
_Mx_Border_Shine_Off:	DC.L	$00000000,$03000011,_Mx_BC_Shine,_Mx_Border_Shadow_Off
_Mx_Border_Shadow_Off:	DC.L	$00000000,$02000011,_Mx_BC_Shadow,0

_Mx_Border_Mx_On:	DC.L	$00000000,$0000001C,_Mx_BC_Center,_Mx_Border_OutTL_On
_Mx_Border_OutTL_On:	DC.L	$00000000,$00000004,_Mx_BC_BlankTL,_Mx_Border_OutBL_On	; tl blank bit
_Mx_Border_OutBL_On:	DC.L	$00000000,$00000004,_Mx_BC_BlankBL,_Mx_Border_OutTR_On	; bl
_Mx_Border_OutTR_On:	DC.L	$00000000,$00000004,_Mx_BC_BlankTR,_Mx_Border_OutBR_On	; tr
_Mx_Border_OutBR_On:	DC.L	$00000000,$00000004,_Mx_BC_BlankBR,_Mx_Border_Shine_On	; br
_Mx_Border_Shine_On:	DC.L	$00000000,$02000011,_Mx_BC_Shine,_Mx_Border_Shadow_On
_Mx_Border_Shadow_On:	DC.L	$00000000,$03000011,_Mx_BC_Shadow,0

_Mx_BC_Center:		DC.W	02,03, 02,05, 03,06, 03,02, 04,02, 04,06, 05,06, 05,02, 06,01, 06,07, 07,07, 07,01, 08,01, 08,07, 09,07, 09,01, 10,01, 10,07, 11,07, 11,01, 12,02, 12,06, 13,06, 13,02, 14,02, 14,06, 15,05, 15,03
_Mx_BC_BlankTL:		DC.W	05,00, 00,00, 00,02, 01,01
_Mx_BC_BlankBL:		DC.W	05,08, 00,08, 00,06, 01,07
_Mx_BC_BlankTR:		DC.W	12,00, 17,00, 17,02, 16,01
_Mx_BC_BlankBR:		DC.W	12,08, 17,08, 17,06, 16,07
_Mx_BC_Shine:		DC.W	14,01, 12,01, 11,00, 06,00, 05,01, 02,01, 02,02, 01,02, 00,03, 01,03, 00,04, 01,04, 00,05, 01,05, 01,06, 02,06, 02,07
_Mx_BC_Shadow:		DC.W	03,07, 05,07, 06,08, 11,08, 12,07, 15,07, 15,06, 16,06, 17,05, 16,05, 17,04, 16,04, 17,03, 16,03, 16,02, 15,02, 15,01

_Remove_All_Window_Gadgets:	; a0 - window
	push	d0/a0-a1
	push	a0
	move.l	wd_FirstGadget(a0),a0
	call	_Count_Gadgets
	move.l	a0,a1
	pop	a0
	call	_RemoveGList
	pop	d0/a0-a1
	rts

_Remove_Work_Gadgets:		; a0 - gadget list
	move.l	a0,d0
.gadget_next
	tst.l	d0
	beq.s	.gadget_end
	move.l	d0,a0
	move.l	gg_NextGadget(a0),a1
	push	a0-a1
	call	_Free
	pop	a0-a1
	move.l	a1,d0
	bra.s	.gadget_next
.gadget_end
	rts

_Create_All_Image_Info_Bytes:
	lea	_Work_Image_Sizes,a0
	moveq.l	#32,d7		; amount
	moveq.l	#20,d0		; w
	moveq.l	#10,d1		; h
	bra.s	.1_pass
.1
	move.b	d0,(a0)+
	move.b	d1,(a0)+
.1_pass
	dbra	d7,.1

	moveq.l	#2,d7		; amount
	moveq.l	#30,d0		; w
	moveq.l	#06,d1		; h
	bra.s	.2_pass
.2
	move.b	d0,(a0)+
	move.b	d1,(a0)+
.2_pass
	dbra	d7,.2

	moveq.l	#5,d7		; amount
	moveq.l	#5,d0		; w
	moveq.l	#5,d1		; h
	bra.s	.3_pass
.3
	move.b	d0,(a0)+
	move.b	d1,(a0)+
.3_pass
	dbra	d7,.3

	move.b	#12,(a0)+
	move.b	#09,(a0)+


	moveq.l	#20,d7		; amount
	moveq.l	#28,d0		; w
	moveq.l	#14,d1		; h
	bra.s	.4_pass
.4
	move.b	d0,(a0)+
	move.b	d1,(a0)+
.4_pass
	dbra	d7,.4

	moveq.l	#5,d7		; amount
	moveq.l	#5,d0		; w
	moveq.l	#5,d1		; h
	bra.s	.5_pass
.5
	move.b	d0,(a0)+
	move.b	d1,(a0)+
.5_pass
	dbra	d7,.5

	moveq.l	#2,d7		; amount
	moveq.l	#10,d0		; w
	moveq.l	#5,d1		; h
	bra.s	.6_pass
.6
	move.b	d0,(a0)+
	move.b	d1,(a0)+
.6_pass
	dbra	d7,.6


	moveq.l	#4,d7		; amount
	moveq.l	#14,d0		; w
	moveq.l	#7,d1		; h
	bra.s	.7_pass
.7
	move.b	d0,(a0)+
	move.b	d1,(a0)+
.7_pass
	dbra	d7,.7


	move.b	#14,(a0)+	; pt up
	move.b	#05,(a0)+

	move.b	#10,(a0)+	; pt right
	move.b	#07,(a0)+

	move.b	#14,(a0)+	; pt down
	move.b	#05,(a0)+

	move.b	#10,(a0)+	; pt left
	move.b	#07,(a0)+

	move.b	#14,(a0)+	; hash
	move.b	#07,(a0)+

	move.b	#12,(a0)+	; new arrow left
	move.b	#07,(a0)+

	move.b	#12,(a0)+	; new arrow right
	move.b	#07,(a0)+

	move.b	#22,(a0)+	; iconize
	move.b	#09,(a0)+

	move.b	#22,(a0)+	; behind
	move.b	#09,(a0)+

	rts





;*****************************
; Intuition Message Functions
;*****************************

_ReplyMsg:		; a1 - message
	push	a6
	move.l	_SysBase,a6
	jsr	_LVOReplyMsg(a6)
	pop	a6
	rts

_GetMsg:		; a0 - userport
	push	a6
	move.l	_SysBase,a6
	jsr	_LVOGetMsg(a6)
	pop	a6
	rts

_Copy_Intuition_Message:		; d0 - message
	push	d0/a0-a1
	move.l	d0,a0			; copy from int message original
	lea	_Message,a1		; copy to intuition message buffer
	move.l	#(im_SIZEOF/4)-1,d0
.1
	move.l	(a0)+,(a1)+
	dbra	d0,.1
	pop	d0/a0-a1
	rts

;*****************************
; Intuition Gadget Functions
;*****************************

_RefreshGadgets:	; a0 - firstgadget, a1 - window,
	push	a2/a6
	sub.l	a2,a2
	move.l	_IntuitionBase,a6
	jsr	_LVORefreshGadgets(a6)
	pop	a2/a6
	rts

_RefreshGList:		;  d0 - numgads, a0 - gadgets, a1 - window
	push	a2/a6
	sub.l	a2,a2
	move.l	_IntuitionBase,a6
	jsr	_LVORefreshGList(a6)
	pop	a2/a6
	rts

_AddGList:		;  d0 - position, d1 - # gadgets, a0 - window, a1 - firstgadget
	push	a2/a6
	sub.l	a2,a2
	move.l	_IntuitionBase,a6
	jsr	_LVOAddGList(a6)
	pop	a2/a6
	rts


_RemoveGList:		; d0 - numgads, a0 - window, a1 - firstgadget
	push	a6
	move.l	_IntuitionBase,a6
	jsr	_LVORemoveGList(a6)
	pop	a6
	rts


_ResetButton:		; d0 - gadget ID, a0 - gadgets, a1 - window
	bsr	_ResetGadget
	moveq.l	#1,d0
	bsr	_RefreshGList
	rts

_SetButton:		; d0 - gadget ID, a0 - gadgets, a1 - window
	bsr	_SetGadget
	moveq.l	#1,d0
	bsr	_RefreshGList
	rts


_SetGadget:		; d0 - gadget ID, a0 - gadget list
	bsr	_Find_GadgetID
	ori.w	#(GFLG_SELECTED),gg_Flags(a0)	; turn on gadget
;	andi.w	#~(GACT_RELVERIFY|GACT_TOGGLESELECT),gg_Activation(a0)
	rts

_ResetGadget:		; d0 - gadget ID, a0 - gadget list
	bsr	_Find_GadgetID
	andi.w	#~(GFLG_SELECTED),gg_Flags(a0)	; turn off gadget
;	ori.w	#(GACT_RELVERIFY|GACT_TOGGLESELECT),gg_Activation(a0)
	rts

_Disable_Gadget:		; a0 - gadgets to disable
	ori.w	#GFLG_DISABLED,gg_Flags(a0)
	rts

_Enable_Gadget:			; a0 - gadget to enable
	andi.w	#~GFLG_DISABLED,gg_Flags(a0)
	rts

_Find_GadgetID:		; d0 - gadget ID, a0 - gadgets
.next_gadget
	cmpa.l	#0,a0
	beq.s	.find_end
	cmp.w	gg_GadgetID(a0),d0
	beq.s	.find_end
	move.l	gg_NextGadget(a0),a0
	bra.s	.next_gadget
.find_end
	rts

_Count_Gadgets:		; a0 - gadget list
	push	a0
	moveq.l	#0,d0
.next_gadget
	cmpa.l	#0,a0
	beq.s	.find_end
	move.l	gg_NextGadget(a0),a0
	addq.l	#1,d0
	bra.s	.next_gadget
.find_end
	pop	a0
	rts

_ResetGadgets:	; d0 - first gadget ID, d1 - count, a0 - gadgets
	bsr	_Find_GadgetID
	push	a0
	bra.s	.next_gadget_1
.next_gadget
	andi.w	#~(GFLG_SELECTED),gg_Flags(a0)
	ori.w	#(GACT_TOGGLESELECT),gg_Activation(a0)	
	move.l	gg_NextGadget(a0),a0
.next_gadget_1
	dbra	d1,.next_gadget
	pop	a0
	rts


 ENDC
